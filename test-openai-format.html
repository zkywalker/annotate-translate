<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenAI Response Format Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }
        .test-case {
            background: #f5f5f5;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #4CAF50;
        }
        .result {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border: 1px solid #ddd;
        }
        .phonetics, .definitions {
            margin: 10px 0;
            padding: 10px;
            background: #e8f5e9;
        }
        .error {
            color: red;
            background: #ffebee;
            padding: 10px;
        }
        pre {
            background: #263238;
            color: #aed581;
            padding: 10px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>ğŸ§ª OpenAI Response Format Test</h1>
    <p>æµ‹è¯• OpenAI Provider çš„å“åº”è§£æå’Œæ•°æ®æ ¼å¼è½¬æ¢</p>

    <div id="results"></div>

    <script src="ai-providers/prompt-templates.js"></script>
    <script src="ai-providers/base-ai-provider.js"></script>
    <script src="ai-providers/openai-provider.js"></script>

    <script>
        const results = document.getElementById('results');

        function addTestCase(title, content) {
            const div = document.createElement('div');
            div.className = 'test-case';
            div.innerHTML = `<h3>${title}</h3>${content}`;
            results.appendChild(div);
        }

        function formatObject(obj) {
            return `<pre>${JSON.stringify(obj, null, 2)}</pre>`;
        }

        // æµ‹è¯•ç”¨ä¾‹ 1: æ¨¡æ‹Ÿ DeepSeek è¿”å›çš„å“åº”
        addTestCase('Test 1: è§£æ DeepSeek å“åº” (chamber â†’ æˆ¿é—´)', '');
        
        const mockResponse = {
            "translation": "æˆ¿é—´",
            "phonetic": "fÃ¡ng jiÄn",  // âŒ é”™è¯¯ï¼šè¿™æ˜¯ä¸­æ–‡æ‹¼éŸ³ï¼Œåº”è¯¥æ˜¯è‹±æ–‡ IPA
            "definitions": ["å»ºç­‘ç‰©å†…ç”±å¢™å£ã€åœ°æ¿å’Œå¤©èŠ±æ¿å›´åˆçš„ç©ºé—´", "ç‰¹å®šç”¨é€”çš„å°é—­ç©ºé—´ï¼ˆå¦‚ä¼šè®®å…ã€å§å®¤ï¼‰"]
        };

        try {
            // åˆ›å»ºæµ‹è¯• provider
            const testProvider = new OpenAIProvider({
                apiKey: 'test-key',
                model: 'gpt-3.5-turbo',
                baseURL: 'https://api.openai.com/v1'
            });

            // è§£æå“åº”
            const rawResponse = JSON.stringify(mockResponse);
            const parsedResult = testProvider.parseJsonResponse(
                rawResponse,
                'chamber',  // originalText
                'en',       // sourceLang
                'zh-CN'     // targetLang
            );

            let html = '<div class="result">';
            html += '<h4>åŸå§‹ AI å“åº”:</h4>';
            html += formatObject(mockResponse);
            
            html += '<h4>è§£æåçš„ TranslationResult:</h4>';
            html += formatObject(parsedResult);

            html += '<h4>æ•°æ®éªŒè¯:</h4>';
            html += '<div class="phonetics">';
            html += `<strong>éŸ³æ ‡ (phonetics):</strong><br>`;
            html += `- ç±»å‹: ${Array.isArray(parsedResult.phonetics) ? 'Array âœ…' : 'Not Array âŒ'}<br>`;
            html += `- é•¿åº¦: ${parsedResult.phonetics.length}<br>`;
            if (parsedResult.phonetics.length > 0) {
                html += `- phonetics[0].text: "${parsedResult.phonetics[0].text}"<br>`;
                html += `- phonetics[0].type: "${parsedResult.phonetics[0].type}"<br>`;
                html += `- é—®é¢˜: âš ï¸ éŸ³æ ‡æ˜¯ä¸­æ–‡æ‹¼éŸ³ï¼Œåº”è¯¥æ˜¯è‹±æ–‡ IPA (å¦‚ /ËˆtÊƒeÉªmbÉ™(r)/)<br>`;
            }
            html += '</div>';

            html += '<div class="definitions">';
            html += `<strong>é‡Šä¹‰ (definitions):</strong><br>`;
            html += `- ç±»å‹: ${Array.isArray(parsedResult.definitions) ? 'Array âœ…' : 'Not Array âŒ'}<br>`;
            html += `- é•¿åº¦: ${parsedResult.definitions.length}<br>`;
            parsedResult.definitions.forEach((def, i) => {
                html += `- definitions[${i}]:<br>`;
                html += `  Â· partOfSpeech: "${def.partOfSpeech}"<br>`;
                html += `  Â· text: "${def.text}"<br>`;
            });
            html += '</div>';

            html += '</div>';
            
            results.lastChild.innerHTML += html;

        } catch (error) {
            results.lastChild.innerHTML += `<div class="error">âŒ Error: ${error.message}</div>`;
            console.error(error);
        }

        // æµ‹è¯•ç”¨ä¾‹ 2: æ­£ç¡®çš„å“åº”æ ¼å¼
        addTestCase('Test 2: æœŸæœ›çš„æ­£ç¡®æ ¼å¼ (chamber â†’ æˆ¿é—´)', '');
        
        const correctResponse = {
            "translation": "æˆ¿é—´",
            "phonetic": "/ËˆtÊƒeÉªmbÉ™(r)/",  // âœ… æ­£ç¡®ï¼šè‹±æ–‡ IPA
            "definitions": ["å»ºç­‘ç‰©å†…ç”±å¢™å£ã€åœ°æ¿å’Œå¤©èŠ±æ¿å›´åˆçš„ç©ºé—´", "ç‰¹å®šç”¨é€”çš„å°é—­ç©ºé—´ï¼ˆå¦‚ä¼šè®®å…ã€å§å®¤ï¼‰"]
        };

        try {
            const testProvider = new OpenAIProvider({
                apiKey: 'test-key',
                model: 'gpt-3.5-turbo',
                baseURL: 'https://api.openai.com/v1'
            });

            const rawResponse = JSON.stringify(correctResponse);
            const parsedResult = testProvider.parseJsonResponse(
                rawResponse,
                'chamber',
                'en',
                'zh-CN'
            );

            let html = '<div class="result">';
            html += '<h4>æ­£ç¡®çš„ AI å“åº”:</h4>';
            html += formatObject(correctResponse);
            
            html += '<h4>è§£æåçš„ TranslationResult:</h4>';
            html += formatObject(parsedResult);

            html += '<h4>æ•°æ®éªŒè¯:</h4>';
            html += '<div class="phonetics">';
            html += `<strong>éŸ³æ ‡ (phonetics):</strong><br>`;
            html += `- phonetics[0].text: "${parsedResult.phonetics[0].text}" âœ…<br>`;
            html += `- phonetics[0].type: "${parsedResult.phonetics[0].type}" âœ…<br>`;
            html += '</div>';

            html += '<div class="definitions">';
            html += `<strong>é‡Šä¹‰ (definitions):</strong><br>`;
            html += `- æ•°é‡: ${parsedResult.definitions.length} âœ…<br>`;
            parsedResult.definitions.forEach((def, i) => {
                html += `- definitions[${i}].text: "${def.text}" âœ…<br>`;
            });
            html += '</div>';

            html += '</div>';
            
            results.lastChild.innerHTML += html;

        } catch (error) {
            results.lastChild.innerHTML += `<div class="error">âŒ Error: ${error.message}</div>`;
            console.error(error);
        }

        // æµ‹è¯•ç”¨ä¾‹ 3: ä¸­æ–‡ â†’ è‹±æ–‡ï¼ˆæ‹¼éŸ³ï¼‰
        addTestCase('Test 3: ä¸­æ–‡ â†’ è‹±æ–‡ (æˆ¿é—´ â†’ room)', '');
        
        const chineseResponse = {
            "translation": "room",
            "phonetic": "fÃ¡ng jiÄn",  // âœ… æ­£ç¡®ï¼šæºæ–‡æœ¬ï¼ˆæˆ¿é—´ï¼‰çš„æ‹¼éŸ³
            "definitions": ["a space enclosed by walls, floor, and ceiling", "a chamber for a specific purpose"]
        };

        try {
            const testProvider = new OpenAIProvider({
                apiKey: 'test-key',
                model: 'gpt-3.5-turbo',
                baseURL: 'https://api.openai.com/v1'
            });

            const rawResponse = JSON.stringify(chineseResponse);
            const parsedResult = testProvider.parseJsonResponse(
                rawResponse,
                'æˆ¿é—´',
                'zh-CN',
                'en'
            );

            let html = '<div class="result">';
            html += '<h4>ä¸­æ–‡æºæ–‡æœ¬çš„å“åº”:</h4>';
            html += formatObject(chineseResponse);
            
            html += '<h4>è§£æå:</h4>';
            html += formatObject(parsedResult);

            html += '<h4>éªŒè¯:</h4>';
            html += `- éŸ³æ ‡ç±»å‹: ${parsedResult.phonetics[0].type} (åº”è¯¥æ˜¯ 'pinyin') âœ…<br>`;
            html += `- éŸ³æ ‡æ–‡æœ¬: ${parsedResult.phonetics[0].text} âœ…<br>`;

            html += '</div>';
            
            results.lastChild.innerHTML += html;

        } catch (error) {
            results.lastChild.innerHTML += `<div class="error">âŒ Error: ${error.message}</div>`;
            console.error(error);
        }

        // æ˜¾ç¤ºæç¤ºè¯
        addTestCase('ğŸ“‹ æ›´æ–°åçš„æç¤ºè¯æ¨¡æ¿', '');
        const template = PromptTemplates.DEFAULT_TEMPLATES.jsonFormat;
        results.lastChild.innerHTML += `
            <div class="result">
                <h4>System Prompt:</h4>
                <pre>${template.system}</pre>
                <h4>User Prompt Template:</h4>
                <pre>${template.user}</pre>
            </div>
        `;

        // æ€»ç»“
        addTestCase('âœ… ä¿®å¤è¯´æ˜', `
            <div class="result">
                <h4>é—®é¢˜ 1: éŸ³æ ‡é”™è¯¯</h4>
                <p><strong>åŸå› :</strong> æç¤ºè¯ä¸å¤Ÿæ˜ç¡®ï¼ŒAI è¿”å›äº†ç¿»è¯‘ç»“æœçš„æ‹¼éŸ³è€Œä¸æ˜¯æºæ–‡æœ¬çš„éŸ³æ ‡</p>
                <p><strong>ä¿®å¤:</strong> åœ¨æç¤ºè¯ä¸­æ˜ç¡®è¦æ±‚ "phonetic transcription of the SOURCE text (original text, not translation)"</p>
                
                <h4>é—®é¢˜ 2: é‡Šä¹‰æ˜¾ç¤ºä¸ºç©º</h4>
                <p><strong>åŸå› :</strong> AI è¿”å›çš„æ˜¯ç®€å•çš„å­—ç¬¦ä¸²æ•°ç»„ï¼Œä½† TranslationResult éœ€è¦çš„æ˜¯ Definition å¯¹è±¡æ•°ç»„ï¼ˆåŒ…å« partOfSpeech å’Œ textï¼‰</p>
                <p><strong>ä¿®å¤:</strong> åœ¨ parseJsonResponse ä¸­å°†å­—ç¬¦ä¸²æ•°ç»„è½¬æ¢ä¸º Definition å¯¹è±¡æ•°ç»„</p>
                
                <h4>æ•°æ®æ ¼å¼è½¬æ¢:</h4>
                <ul>
                    <li>AI è¿”å›: <code>{ phonetic: "string", definitions: ["string1", "string2"] }</code></li>
                    <li>è½¬æ¢ä¸º: <code>{ phonetics: [{text: "string", type: "ipa"}], definitions: [{partOfSpeech: "", text: "string1"}, ...] }</code></li>
                </ul>
            </div>
        `);

    </script>
</body>
</html>
